<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Smooth</name>
    </assembly>
    <members>
        <member name="T:Smooth.Algebraics.Either`2">
            <summary>
            Struct representing a value that can be an instance of either the L (left) or the R (right) type.
            </summary>
        </member>
        <member name="F:Smooth.Algebraics.Either`2.isLeft">
            <summary>
            True if the either contains an L value; otherwise, false;
            </summary>
        </member>
        <member name="F:Smooth.Algebraics.Either`2.leftValue">
            <summary>
            If the either isLeft, the value contained by the either; otherwise, default(L).
            </summary>
        </member>
        <member name="F:Smooth.Algebraics.Either`2.rightValue">
            <summary>
            If the either isRight, the value contained by the either; otherwise, default(R).
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.Left(`0)">
            <summary>
            Returns a left either containing the specified value.
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.Right(`1)">
            <summary>
            Returns a right either containing the specified value.
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.Cata``1(Smooth.Delegates.DelegateFunc{`0,``0},Smooth.Delegates.DelegateFunc{`1,``0})">
            <summary>
            If the either isLeft, returns leftFunc applied to the either's value; otherwise, returns rightFunc applied to the either's value.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.Cata``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,Smooth.Delegates.DelegateFunc{`1,``0})">
            <summary>
            If the either isLeft, returns leftFunc applied to the either's value and p; otherwise, returns rightFunc applied to the either's value.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.Cata``2(Smooth.Delegates.DelegateFunc{`0,``0},Smooth.Delegates.DelegateFunc{`1,``1,``0},``1)">
            <summary>
            If the either isLeft, returns leftFunc applied to the either's value; otherwise, returns rightFunc applied to the either's value and p2.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.Cata``3(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,Smooth.Delegates.DelegateFunc{`1,``2,``0},``2)">
            <summary>
            If the either isLeft, returns leftFunc applied to the either's value and p; otherwise, returns rightFunc applied to the either's value and p2.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.ForEach(Smooth.Delegates.DelegateAction{`0},Smooth.Delegates.DelegateAction{`1})">
            <summary>
            If the either isLeft, applies leftAction to the either's value; otherwise, applies rightAction to the either's value.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.ForEach``1(Smooth.Delegates.DelegateAction{`0,``0},``0,Smooth.Delegates.DelegateAction{`1})">
            <summary>
            If the either isLeft, applies leftAction to the either's value and p; otherwise, applies rightAction to the either's value.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.ForEach``1(Smooth.Delegates.DelegateAction{`0},Smooth.Delegates.DelegateAction{`1,``0},``0)">
            <summary>
            If the either isLeft, applies leftAction to the either's value; otherwise, applies rightAction to the either's value and p2.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Either`2.ForEach``2(Smooth.Delegates.DelegateAction{`0,``0},``0,Smooth.Delegates.DelegateAction{`1,``1},``1)">
            <summary>
            If the either isLeft, applies leftAction to the either's value and p; otherwise, applies rightAction to the either's value and p2.
            </summary>
        </member>
        <member name="P:Smooth.Algebraics.Either`2.isRight">
            <summary>
            True if the either contains an R value; otherwise, false;
            </summary>
        </member>
        <member name="P:Smooth.Algebraics.Either`2.leftOption">
            <summary>
            If the either isLeft, the an option containing the either's value; otherwise, an empty option.
            </summary>
        </member>
        <member name="P:Smooth.Algebraics.Either`2.rightOption">
            <summary>
            If the either isRight, the an option containing the either's value; otherwise, an empty option.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Algebraics.Option" -->
        <member name="M:Smooth.Algebraics.Option.Create``1(``0)">
            <summary>
            Returns None if value == null; otherwise, Some(value).
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option.Some``1(``0)">
            <summary>
            Returns Some(value), regardless of whether or not value == null.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option.None``1(``0)">
            <summary>
            Returns None.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option.ToOption``1(``0)">
            <summary>
            Returns None if value == null; otherwise, Some(value).
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option.ToSome``1(``0)">
            <summary>
            Returns Some(value), regardless of whether or not value == null.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option.ToNone``1(``0)">
            <summary>
            Returns None.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option.Flatten``1(Smooth.Algebraics.Option{Smooth.Algebraics.Option{``0}})">
            <summary>
            Flattens a nested option.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Algebraics.Option`1" -->
        <member name="F:Smooth.Algebraics.Option`1.None">
            <summary>
            A static None option for type T.
            </summary>
        </member>
        <member name="F:Smooth.Algebraics.Option`1.isSome">
            <summary>
            True if the option contains a value; otherwise, false.
            </summary>
        </member>
        <member name="F:Smooth.Algebraics.Option`1.value">
            <summary>
            If the option isSome, the value contained by the option; otherwise, default(T).
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.#ctor(`0)">
            <summary>
            Creates a Some option that contains the specified value.
            
            Note: Use the default contructor to create a None option.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Cata``1(Smooth.Delegates.DelegateFunc{`0,``0},``0)">
            <summary>
            If the option isSome, returns the result of someFunc applied to the option's value; otherwise, returns noneValue.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Cata``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,``0)">
            <summary>
            If the option isSome, returns the result of someFunc applied to the option's value and p; otherwise, returns noneValue.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Cata``1(Smooth.Delegates.DelegateFunc{`0,``0},Smooth.Delegates.DelegateFunc{``0})">
            <summary>
            If the option isSome, returns the result of someFunc applied to the option's value; otherwise, returns the result of noneFunc.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Cata``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,Smooth.Delegates.DelegateFunc{``0})">
            <summary>
            If the option isSome, returns the result of someFunc applied to the option's value and p; otherwise, returns the result of noneFunc.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Cata``3(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,Smooth.Delegates.DelegateFunc{``2,``0},``2)">
            <summary>
            If the option isSome, returns the result of someFunc applied to the option's value and p; otherwise, returns the result of noneFunc applied to p2.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Contains(`0)">
            <summary>
            Returns true if the option contains the specified value according to the default equality comparer; otherwise, false.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Contains(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns true if the option contains the specified value according to the specified equality comparer; otherwise, false.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.IfEmpty(Smooth.Delegates.DelegateAction)">
            <summary>
            If the option isNone, invokes the specified delegate; otherwise, does nothing.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.IfEmpty``1(Smooth.Delegates.DelegateAction{``0},``0)">
            <summary>
            If the option isNone, invokes the specified delegate with p; otherwise, does nothing.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.ForEach(Smooth.Delegates.DelegateAction{`0})">
            <summary>
            If the option isSome, invokes the specified delegate with the option's value; otherwise, does nothing.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.ForEach``1(Smooth.Delegates.DelegateAction{`0,``0},``0)">
            <summary>
            If the option isSome, invokes the specified delegate with the option's value and p; otherwise, does nothing.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.ForEachOr(Smooth.Delegates.DelegateAction{`0},Smooth.Delegates.DelegateAction)">
            <summary>
            If the option isSome, invokes the someAction with the option's value; otherwise, invokes noneAction.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.ForEachOr``1(Smooth.Delegates.DelegateAction{`0,``0},``0,Smooth.Delegates.DelegateAction)">
            <summary>
            If the option isSome, invokes the someAction with the option's value and p; otherwise, invokes noneAction.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.ForEachOr``1(Smooth.Delegates.DelegateAction{`0},Smooth.Delegates.DelegateAction{``0},``0)">
            <summary>
            If the option isSome, invokes the someAction with the option's value; otherwise, invokes noneAction with p2.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.ForEachOr``2(Smooth.Delegates.DelegateAction{`0,``0},``0,Smooth.Delegates.DelegateAction{``1},``1)">
            <summary>
            If the option isSome, invokes the someAction with the option's value and p; otherwise, invokes noneAction with p2.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Or(Smooth.Algebraics.Option{`0})">
            <summary>
            If the option isSome, returns the option; otherwise, returns noneOption.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Or(Smooth.Delegates.DelegateFunc{Smooth.Algebraics.Option{`0}})">
            <summary>
            If the option isSome, returns the option; otherwise, returns the result of noneFunc.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Or``1(Smooth.Delegates.DelegateFunc{``0,Smooth.Algebraics.Option{`0}},``0)">
            <summary>
            If the option isSome, returns the option; otherwise, returns the result of noneFunc applied to p.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Select``1(Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            If the option isSome, returns an option containing the specified selector applied to the option's value; otherwise, returns an empty option.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Select``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)">
            <summary>
            If the option isSome, returns an option containing the specified selector applied to the option's value and p; otherwise, returns an empty option.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.SelectMany``1(Smooth.Delegates.DelegateFunc{`0,Smooth.Algebraics.Option{``0}})">
            <summary>
            If the option isSome, returns the specified selector applied to the option's value; otherwise, returns an empty option.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.SelectMany``2(Smooth.Delegates.DelegateFunc{`0,``1,Smooth.Algebraics.Option{``0}},``1)">
            <summary>
            If the option isSome, returns the specified selector applied to the option's value and p; otherwise, returns an empty option.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.ValueOr(`0)">
            <summary>
            If the option isSome, returns the option's value; otherwise, returns noneValue.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.ValueOr(Smooth.Delegates.DelegateFunc{`0})">
            <summary>
            If the option isSome, returns the option's value; otherwise, returns the result of noneFunc.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.ValueOr``1(Smooth.Delegates.DelegateFunc{``0,`0},``0)">
            <summary>
            If the option isSome, returns the option's value; otherwise, returns the result of noneFunc applied to p.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Where(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            If the option isSome and the specified predicate applied to the option's value is true, returns the option; otherwise, returns an empty option.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.Where``1(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0)">
            <summary>
            If the option isSome and the specified predicate applied to the option's value and p is true, returns the option; otherwise, returns an empty option.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.WhereNot(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            If the option isSome and the specified predicate applied to the option's value is false, returns the option; otherwise, returns an empty option.
            </summary>
        </member>
        <member name="M:Smooth.Algebraics.Option`1.WhereNot``1(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0)">
            <summary>
            If the option isSome and the specified predicate applied to the option's value and p is false, returns the option; otherwise, returns an empty option.
            </summary>
        </member>
        <member name="P:Smooth.Algebraics.Option`1.isNone">
            <summary>
            True if the option is empty; otherwise, false.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Algebraics.Tuple" -->
        <member name="T:Smooth.Algebraics.Tuple`1">
            <summary>
            Struct representing a sequence of one element, aka: a singleton.
            </summary>
        </member>
        <member name="T:Smooth.Algebraics.Tuple`2">
            <summary>
            Struct representing a sequence of two elements, aka: an ordered pair.
            </summary>
        </member>
        <member name="T:Smooth.Algebraics.Tuple`3">
            <summary>
            Struct representing a sequence of three elements, aka: an ordered triplet.
            </summary>
        </member>
        <member name="T:Smooth.Algebraics.Tuple`4">
            <summary>
            Struct representing a sequence of four elements.
            </summary>
        </member>
        <member name="T:Smooth.Algebraics.Tuple`5">
            <summary>
            Struct representing a sequence of five elements.
            </summary>
        </member>
        <member name="T:Smooth.Algebraics.Tuple`6">
            <summary>
            Struct representing a sequence of six elements.
            </summary>
        </member>
        <member name="T:Smooth.Algebraics.Tuple`7">
            <summary>
            Struct representing a sequence of seven elements.
            </summary>
        </member>
        <member name="T:Smooth.Algebraics.Tuple`8">
            <summary>
            Struct representing a sequence of eight elements.
            </summary>
        </member>
        <member name="T:Smooth.Algebraics.Tuple`9">
            <summary>
            Struct representing a sequence of nine elements.
            </summary>
        </member>
        <member name="T:Smooth.Algebraics.Unit">
            <summary>
            Represents a type that holds no information.  Units have no state, and all instances of Unit are considered equal.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.Comparer`1" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.Dictionary" -->
        <member name="M:Smooth.Collections.Dictionary.Create``2">
            <summary>
            Creates a new dictionary with the default comparer.
            </summary>
        </member>
        <member name="M:Smooth.Collections.Dictionary.Create``2(System.Int32)">
            <summary>
            Creates a new dictionary with the default comparer and the specified initial capacity.
            </summary>
        </member>
        <member name="M:Smooth.Collections.Dictionary.Create``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Creates a new dictionary with the default comparer and elements copied from the specified dictionary.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.HashSet" -->
        <member name="M:Smooth.Collections.HashSet.Create``1">
            <summary>
            Creates a new hash set with the default comparer.
            </summary>
        </member>
        <member name="M:Smooth.Collections.HashSet.Create``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a new hash set with the default comparer and elements copied from the specified collection.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.SortedDictionary" -->
        <member name="M:Smooth.Collections.SortedDictionary.Create``2">
            <summary>
            Creates a new sorted dictionary with the default comparer.
            </summary>
        </member>
        <member name="M:Smooth.Collections.SortedDictionary.Create``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Creates a new sorted dictionary with the default comparer and elements copied from the specified dictionary.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.SortedList" -->
        <member name="M:Smooth.Collections.SortedList.Create``2">
            <summary>
            Creates a new sorted list with the default comparer.
            </summary>
        </member>
        <member name="M:Smooth.Collections.SortedList.Create``2(System.Int32)">
            <summary>
            Creates a new sorted list with the default comparer and the specified initial capacity.
            </summary>
        </member>
        <member name="M:Smooth.Collections.SortedList.Create``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Creates a new sorted list with the default comparer and elements copied from the specified dictionary.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.EqualityComparer`1" -->
        <member name="T:Smooth.Collections.FuncEnumerable`1">
            <summary>
            Enumerable that contains the elements defined by a seed value and step function.
            </summary>
        </member>
        <member name="T:Smooth.Collections.FuncEnumerable`2">
            <summary>
            Enumerable that contains the elements defined by a seed value and step function.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.ICollectionExtensions" -->
        <member name="M:Smooth.Collections.ICollectionExtensions.AddAll``2(``0,``1[])">
            <summary>
            Adds the specified values to and returns the specific collection.
            </summary>
        </member>
        <member name="M:Smooth.Collections.ICollectionExtensions.AddAll``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Adds the specified values to and returns the specific collection.
            </summary>
        </member>
        <member name="M:Smooth.Collections.ICollectionExtensions.AddAll``2(``0,System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Adds the specified values to and returns the specific collection.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.IDictionaryExtensions" -->
        <member name="M:Smooth.Collections.IDictionaryExtensions.TryGet``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Analog to IDictionary&lt;K, V&gt;.TryGetValue(K, out V) that returns an option instead of using an out parameter.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.IListExtensions" -->
        <member name="M:Smooth.Collections.IListExtensions.Random``1(System.Collections.Generic.IList{``0})">
            <summary>
            If the specified list is empty, returns an empty option; otherwise, returns an option containing a random element from the specified list.
            </summary>
        </member>
        <member name="M:Smooth.Collections.IListExtensions.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            Shuffles the element order of the specified list.
            </summary>
        </member>
        <member name="M:Smooth.Collections.IListExtensions.InsertionSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the specified list using an insertion sort algorithm and the default sort comparer for T.
            </summary>
            <remarks>
            Insertion sort is a O(n²) time complexity algorithm and should not be used on arbitrary lists.
            However, it has a best case time complexity of O(n) for lists that are already sorted and is quite fast when used on nearly sorted input.
            </remarks>
        </member>
        <member name="M:Smooth.Collections.IListExtensions.InsertionSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the specified list using an insertion sort algorithm and the specified comparer.
            </summary>
            <remarks>
            Insertion sort is a O(n²) time complexity algorithm and should not be used on arbitrary lists.
            However, it has a best case time complexity of O(n) for lists that are already sorted and is quite fast when used on nearly sorted input.
            </remarks>
        </member>
        <member name="M:Smooth.Collections.IListExtensions.InsertionSort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            Sorts the specified list using an insertion sort algorithm and the specified comparison.
            </summary>
            <remarks>
            Insertion sort is a O(n²) time complexity algorithm and should not be used on arbitrary lists.
            However, it has a best case time complexity of O(n) for lists that are already sorted and is quite fast when used on nearly sorted input.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.IListStepper`1" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.IListStepperWithIndex`1" -->
        <member name="T:InspectorKeyValuePair`2">
            <summary>
            Class based key value pair for use in inspector lists and arrays.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.LinkedListStepper`1" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Collections.LinkedListStepperNodes`1" -->
        <member name="T:Smooth.Compare.Comparers.Blittable32EqualityComparer`1">
            <summary>
            Fast, allocation free equality comparer for blittable structs with an underlying size of 32 bits or less.
            </summary>
        </member>
        <member name="T:Smooth.Compare.Comparers.Blittable64EqualityComparer`1">
            <summary>
            Fast, allocation free equality comparer for blittable structs with an underlying size of 64 bits or less.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Compare.Comparers.KeyValuePairComparer`2" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Compare.Comparers.KeyValuePairEqualityComparer`2" -->
        <member name="T:Smooth.Compare.Configuration">
            
             Configuration class for Smooth.Compare.
            
             To supply a custom configuration, simply add a class to your project called Smooth.Compare.CustomConfiguration that inherits from this type.
             
             If a custom configuration exists, it will override the the default configuration.
             
             Note: Don't edit this class directly, as it may get updated in future versions of Smooth.Compare.
            
        </member>
        <member name="M:Smooth.Compare.Configuration.#ctor">
            
             Default constructor that simply adds a listener to Finder.OnEvent.
             
             If you supply a custom configuration, don't register types or do any comparsions from the constructor as the finder will not be fully initialized yet.
            
        </member>
        <member name="M:Smooth.Compare.Configuration.RegisterComparers">
            <summary>
            Method called by the finder to set up registrations before any comparer requests are handled.
            
            If you supply a custom configuration and want to apply the default registrations, add a call to base.RegisterComparers() from your method override.
            </summary>
        </member>
        <member name="M:Smooth.Compare.Configuration.HandleFinderEvent(Smooth.Compare.ComparerType,Smooth.Compare.EventType,System.Type)">
            <summary>
            Listens for finder events which are useful for finding potential comparison problems.
            
            The default implementation logs warnings on registration collisions, the use of inefficient or invalid comparers, and unregistered find requests for value types if JIT is disabled.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Configuration.Comparer``1" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Configuration.EqualityComparer``1" -->
        <member name="M:Smooth.Compare.Configuration.Color32ToInt(UnityEngine.Color32)">
            <summary>
            Converts a 32-bit color to a 32-bit integer without loss of information
            </summary>
        </member>
        <member name="P:Smooth.Compare.Configuration.UseJit">
            <summary>
            This can be used to override the platform setting and enable or disable automatic comparer creation, which can be quite useful while testing in different environments.
            </summary>
        </member>
        <member name="P:Smooth.Compare.Configuration.NoJit">
            <summary>
            Convenience method for !UseJit.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Factory.Comparer``1" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Factory.EqualityComparer``1" -->
        <member name="M:Smooth.Compare.Factory.EqualsExpression(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Returns an option containing an expression that compares l and r for equality without casting, or None if no such comparison can be found.
            </summary>
        </member>
        <member name="M:Smooth.Compare.Factory.ExistingComparer``1">
            <summary>
            Returns a tuple containing:
            an Expression for the default sort order comparer for type T, and
            a MethodInfo for the comparer's Compare(T, T) method.
            </summary>
        </member>
        <member name="M:Smooth.Compare.Factory.ExistingComparer(System.Type)">
            <summary>
            Returns a tuple containing:
            an Expression for the default comparer for the specified type, and
            a MethodInfo for the comparer's Compare(T, T) method.
            </summary>
        </member>
        <member name="M:Smooth.Compare.Factory.ExistingEqualityComparer``1">
            <summary>
            Returns a tuple containing:
            an expression for the default equality comparer for type T, and
            a MethodInfo for the comparer's Equals(T, T) method, and
            a MethodInfo for the comparer's GetHashCode(T) method.
            </summary>
        </member>
        <member name="M:Smooth.Compare.Factory.ExistingEqualityComparer(System.Type)">
            <summary>
            Returns a tuple containing:
            an expression for the default equality comparer for the specified type, and
            a MethodInfo for the comparer's Equals(T, T) method, and
            a MethodInfo for the comparer's GetHashCode(T) method.
            </summary>
        </member>
        <member name="T:Smooth.Compare.Finder">
            <summary>
            Manages comparer registration and lookup for Smooth.Compare.
            </summary>
        </member>
        <member name="F:Smooth.Compare.Finder.OnEvent">
            <summary>
            Wrapped caller / delegate for finder events.  To subscribe, add a delegate to the enclosed Handle event.
            </summary>
        </member>
        <member name="M:Smooth.Compare.Finder.RegisterEnum``1">
            <summary>
            Registers an equality comparer for type T where T is an enumeration.
            
            Note: Enumerations are handled automatically and do not need to be registered when JIT is enabled.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Finder.RegisterKeyValuePair``2" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Finder.RegisterIComparable``1" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Finder.RegisterIEquatable``1" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Finder.RegisterIComparableIEquatable``1" -->
        <member name="M:Smooth.Compare.Finder.Register``1(System.Comparison{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Registers a sort order comparer with the specified comparison and an equality comparer with the specified equals function for type T.
            </summary>
        </member>
        <member name="M:Smooth.Compare.Finder.Register``1(System.Comparison{``0},System.Func{``0,``0,System.Boolean},System.Func{``0,System.Int32})">
            <summary>
            Registers a sort order comparer with the specified comparison and an equality comparer with the specified equals and hashCode functions for type T.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Finder.Register``1(System.Collections.Generic.IComparer{``0},System.Collections.Generic.IEqualityComparer{``0})" -->
        <member name="M:Smooth.Compare.Finder.Register``1(System.Comparison{``0})">
            <summary>
            Registers a sort order comparer with the specified comparison for type T.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Finder.Register``1(System.Collections.Generic.IComparer{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Finder.Comparer``1" -->
        <member name="M:Smooth.Compare.Finder.Register``1(System.Func{``0,``0,System.Boolean})">
            <summary>
            Registers an equality comparer with the specified equals function for type T.
            </summary>
        </member>
        <member name="M:Smooth.Compare.Finder.Register``1(System.Func{``0,``0,System.Boolean},System.Func{``0,System.Int32})">
            <summary>
            Registers an equality comparer with the specified equals and hashCode functions for type T.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Finder.Register``1(System.Collections.Generic.IEqualityComparer{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Compare.Finder.EqualityComparer``1" -->
        <member name="T:Smooth.Compare.Utilities.LogUnregisteredOnDestroy">
            <summary>
            Simple utility that listens to finder events and logs all requests for unregistered comparers when the component is destroyed.
            
            This can be useful when running an application meant for a non-JIT platform in a JIT-enabled simulator so you can test many code paths, then track down and fix any potential comparer issues.
            </summary>
        </member>
        <member name="T:Smooth.Comparisons.Comparisons">
            <summary>
            Provides various methods for creating comparisons.
            </summary>
        </member>
        <member name="M:Smooth.Comparisons.Comparisons.Reverse``1(System.Comparison{``0})">
            <summary>
            Reverses the ordering of the specified comparison.
            </summary>
        </member>
        <member name="M:Smooth.Comparisons.Comparisons.NullsFirst``1(System.Comparison{``0})">
            <summary>
            Prepends null sorting to the specified reference type comparison, with nulls preceeding non-nulls.
            </summary>
        </member>
        <member name="M:Smooth.Comparisons.Comparisons.NullsLast``1(System.Comparison{``0})">
            <summary>
            Prepends null sorting to the specified reference type comparison, with nulls suceeding non-nulls.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Comparisons.Comparisons.NullableNullsFirst``1(System.Comparison{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Comparisons.Comparisons.NullableNullsLast``1(System.Comparison{``0})" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Comparisons.Comparisons`1" -->
        <member name="M:Smooth.Comparisons.Comparisons`1.ToComparison(System.Collections.Generic.IComparer{`0})">
            <summary>
            Returns the comparison method of the specfied sort comparer in delegate form.
            </summary>
        </member>
        <member name="M:Smooth.Comparisons.Comparisons`1.ToPredicate(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns the comparison method of the specfied equality comparer in delegate form.
            </summary>
        </member>
        <member name="P:Smooth.Comparisons.Comparisons`1.Default">
            <summary>
            The comparison method of the default sort comparer for T in delegate form.
            </summary>
        </member>
        <member name="P:Smooth.Comparisons.Comparisons`1.DefaultPredicate">
            <summary>
            The comparison method of the default equality comparer for T in delegate form.
            </summary>
        </member>
        <member name="T:Smooth.Comparisons.FuncComparer`1">
            <summary>
            Performs type-specific comparisons using the comparison delegate supplied to the constructor.
            </summary>
        </member>
        <member name="M:Smooth.Comparisons.FuncComparer`1.#ctor(System.Comparison{`0})">
            <summary>
            Instantiate a comparer for type T using the specified comparison
            </summary>
        </member>
        <member name="T:Smooth.Comparisons.FuncEqualityComparer`1">
            <summary>
            Performs type-specific equality comparisons and hashCode generation using the functions supplied to the constructor.
            </summary>
        </member>
        <member name="M:Smooth.Comparisons.FuncEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary>
            Instantiate an equality comparer for type T using the specified equality function and T.GetHashCode()
            </summary>
        </member>
        <member name="M:Smooth.Comparisons.FuncEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Instantiate an equality comparer for type T with the specified equality and hashCode functions
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Comparisons.IComparableComparer`1" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Comparisons.IEquatableEqualityComparer`1" -->
        <member name="T:Smooth.Delegates.DelegateExtensions">
            <summary>
            Provides extension methods related to delegate usage.
            </summary>
        </member>
        <member name="M:Smooth.Delegates.DelegateExtensions.Apply``1(``0,Smooth.Delegates.DelegateAction{``0})">
            <summary>
            Calls the specified action with the specified value.
            </summary>
        </member>
        <member name="M:Smooth.Delegates.DelegateExtensions.Apply``2(``0,Smooth.Delegates.DelegateAction{``0,``1},``1)">
            <summary>
            Calls the specified action with the specified value and parameter.
            </summary>
        </member>
        <member name="M:Smooth.Delegates.DelegateExtensions.Apply``2(``0,Smooth.Delegates.DelegateFunc{``0,``1})">
            <summary>
            Calls the specified function with the specified value and returns the result.
            </summary>
        </member>
        <member name="M:Smooth.Delegates.DelegateExtensions.Apply``3(``0,Smooth.Delegates.DelegateFunc{``0,``2,``1},``2)">
            <summary>
            Calls the specified function with the specified value and parameter and returns the result.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Delegates.Tupled" -->
        <member name="T:Smooth.Dispose.Disposable`1">
            <summary>
            Wrapper around a value that uses the IDisposable interface to dispose of the value.
            
            On IOS, this is a value type to avoid compute_class_bitmap errors.
            
            On other platforms, it is a pooled object to avoid boxing when disposed by a using block with the Unity compiler.
            </summary>
        </member>
        <member name="M:Smooth.Dispose.Disposable`1.Borrow(`0,Smooth.Delegates.DelegateAction{`0})">
            <summary>
            Borrows a wrapper for the specified value and disposal delegate.
            </summary>
        </member>
        <member name="M:Smooth.Dispose.Disposable`1.Dispose">
            <summary>
            Relinquishes ownership of the wrapper, disposes the wrapped value, and returns the wrapper to the pool.
            </summary>
        </member>
        <member name="M:Smooth.Dispose.Disposable`1.DisposeInBackground">
            <summary>
            Relinquishes ownership of the wrapper and adds it to the disposal queue.
            </summary>
        </member>
        <member name="P:Smooth.Dispose.Disposable`1.value">
            <summary>
            The wrapped value.
            </summary>
        </member>
        <member name="T:Smooth.Dispose.DisposalQueue">
            <summary>
            Queues pooled resources for cleanup by a background thread.
            
            By default, the disposal thread is woken up at the end of LateUpdate, when there is likely to be free CPU time available while GPU operations are in progress.
            
            Various pools may be locked and unlocked while resources are released, potentially causing contention if pooled resources are borrowed during the disposal process.
            
            Advanced users who are using pools from the main thread during the rendering phase may want to customize the point in the Unity event loop when the queue lock is pulsed, potentially pulsing from a Camera event.
            </summary>
        </member>
        <member name="M:Smooth.Dispose.DisposalQueue.Enqueue(System.IDisposable)">
            <summary>
            Adds the specified item to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Dispose.DisposalQueue.Pulse">
            <summary>
            Pulses the queue lock, potentially waking up the disposal thread.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent.Raise">
            <summary>
            Raises the wrapped event.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent`1">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent`1.Raise(`0)">
            <summary>
            Raises the wrapped event with the specifed parameter.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent`1.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent`2">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent`2.Raise(`0,`1)">
            <summary>
            Raises the wrapped event with the specifed parameters.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent`2.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent`3">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent`3.Raise(`0,`1,`2)">
            <summary>
            Raises the wrapped event with the specifed parameters.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent`3.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent`4">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent`4.Raise(`0,`1,`2,`3)">
            <summary>
            Raises the wrapped event with the specifed parameters.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent`4.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent`5">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent`5.Raise(`0,`1,`2,`3,`4)">
            <summary>
            Raises the wrapped event with the specifed parameters.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent`5.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent`6">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent`6.Raise(`0,`1,`2,`3,`4,`5)">
            <summary>
            Raises the wrapped event with the specifed parameters.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent`6.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent`7">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent`7.Raise(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Raises the wrapped event with the specifed parameters.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent`7.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent`8">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent`8.Raise(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Raises the wrapped event with the specifed parameters.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent`8.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Events.GenericEvent`9">
            <summary>
            Struct wrapped event that allows raising the event from outside the containing class.
            </summary>
        </member>
        <member name="M:Smooth.Events.GenericEvent`9.Raise(`0,`1,`2,`3,`4,`5,`6,`7,`8)">
            <summary>
            Raises the wrapped event with the specifed parameters.
            </summary>
        </member>
        <member name="E:Smooth.Events.GenericEvent`9.Handle">
            <summary>
            The wrapped event.
            </summary>
        </member>
        <member name="T:Smooth.Platform.BasePlatform">
            <summary>
            Enumeration representing the base platforms for Unity builds.
            </summary>
        </member>
        <member name="T:Smooth.Platform.PlatformExtensions">
            <summary>
            Extension methods related to the runtime / base platform.
            </summary>
        </member>
        <member name="M:Smooth.Platform.PlatformExtensions.ToBasePlatform(UnityEngine.RuntimePlatform)">
            <summary>
            Returns the base platform for the specified runtime platform.
            </summary>
        </member>
        <member name="M:Smooth.Platform.PlatformExtensions.HasJit(UnityEngine.RuntimePlatform)">
            <summary>
            Returns true if the specified platform supports JIT compilation; otherwise, false.
            </summary>
        </member>
        <member name="M:Smooth.Platform.PlatformExtensions.HasJit(Smooth.Platform.BasePlatform)">
            <summary>
            Returns true if the specified platform supports JIT compilation; otherwise, false.
            </summary>
        </member>
        <member name="M:Smooth.Platform.PlatformExtensions.NoJit(UnityEngine.RuntimePlatform)">
            <summary>
            Returns true if the specified platform does not support JIT compilation; otherwise, false.
            </summary>
        </member>
        <member name="M:Smooth.Platform.PlatformExtensions.NoJit(Smooth.Platform.BasePlatform)">
            <summary>
            Returns true if the specified platform does not support JIT compilation; otherwise, false.
            </summary>
        </member>
        <member name="T:Smooth.Platform.Runtime">
            <summary>
            Helper class that provides information about the target platform.
            </summary>
        </member>
        <member name="F:Smooth.Platform.Runtime.platform">
            <summary>
            The target runtime platform.
            </summary>
        </member>
        <member name="F:Smooth.Platform.Runtime.basePlatform">
            <summary>
            The base platform of the target runtime.
            </summary>
        </member>
        <member name="F:Smooth.Platform.Runtime.hasJit">
            <summary>
            True if the base platform supports JIT compilation; otherwise false.
            </summary>
        </member>
        <member name="F:Smooth.Platform.Runtime.noJit">
            <summary>
            True if the base platform does not support JIT compilation; otherwise false.
            </summary>
        </member>
        <member name="T:Smooth.Pools.KeyedPool`2">
            <summary>
            Pool that lends values of type T with an associated key of type K.
            </summary>
        </member>
        <member name="M:Smooth.Pools.KeyedPool`2.#ctor(Smooth.Delegates.DelegateFunc{`0,`1},Smooth.Delegates.DelegateFunc{`1,`0})">
            <summary>
            Creates a new keyed pool with the specified value creation and reset delegates.
            </summary>
        </member>
        <member name="M:Smooth.Pools.KeyedPool`2.Borrow(`0)">
            <summary>
            Borrows a value with the specified key from the pool.
            </summary>
        </member>
        <member name="M:Smooth.Pools.KeyedPool`2.Release(`1)">
            <summary>
            Relinquishes ownership of the specified value and returns it to the pool.
            </summary>
        </member>
        <member name="M:Smooth.Pools.KeyedPool`2.BorrowDisposable(`0)">
            <summary>
            Borrows a wrapped value with the specified key from the pool.
            </summary>
        </member>
        <member name="T:Smooth.Pools.KeyedPoolWithDefaultKey`2">
            <summary>
            Pool that lends values of type T with an associated key of type K and defines a default key.
            </summary>
        </member>
        <member name="M:Smooth.Pools.KeyedPoolWithDefaultKey`2.#ctor(Smooth.Delegates.DelegateFunc{`0,`1},Smooth.Delegates.DelegateFunc{`1,`0},`0)">
            <summary>
            Creates a new keyed pool with the specified creation delegate, reset delegate, and default key.
            </summary>
        </member>
        <member name="M:Smooth.Pools.KeyedPoolWithDefaultKey`2.#ctor(Smooth.Delegates.DelegateFunc{`0,`1},Smooth.Delegates.DelegateFunc{`1,`0},Smooth.Delegates.DelegateFunc{`0})">
            <summary>
            Creates a new keyed pool with the specified creation delegate, reset delegate, and default key.
            </summary>
        </member>
        <member name="M:Smooth.Pools.KeyedPoolWithDefaultKey`2.Borrow">
            <summary>
            Borrows a value with the default key from the pool.
            </summary>
        </member>
        <member name="M:Smooth.Pools.KeyedPoolWithDefaultKey`2.BorrowDisposable">
            <summary>
            Borrows a wrapped value with the default key from the pool.
            </summary>
        </member>
        <member name="T:Smooth.Pools.Pool`1">
            <summary>
            Pool that lends values of type T.
            </summary>
        </member>
        <member name="M:Smooth.Pools.Pool`1.#ctor(Smooth.Delegates.DelegateFunc{`0},Smooth.Delegates.DelegateAction{`0})">
            <summary>
            Creates a new pool with the specified value creation and reset delegates.
            </summary>
        </member>
        <member name="M:Smooth.Pools.Pool`1.Borrow">
            <summary>
            Borrows a value from the pool.
            </summary>
        </member>
        <member name="M:Smooth.Pools.Pool`1.Release(`0)">
            <summary>
            Relinquishes ownership of the specified value and returns it to the pool.
            </summary>
        </member>
        <member name="M:Smooth.Pools.Pool`1.BorrowDisposable">
            <summary>
            Borrows a wrapped value from the pool.
            </summary>
        </member>
        <member name="T:Smooth.Pools.PoolWithInitializer`2">
            <summary>
            Pool that lends values of type T with an optional initializer that takes a value of type U.
            </summary>
        </member>
        <member name="M:Smooth.Pools.PoolWithInitializer`2.#ctor(Smooth.Delegates.DelegateFunc{`0},Smooth.Delegates.DelegateAction{`0},Smooth.Delegates.DelegateAction{`0,`1})">
            <summary>
            Creates a new pool with the specified creation, reset, and initialization delegates.
            </summary>
        </member>
        <member name="M:Smooth.Pools.PoolWithInitializer`2.Borrow(`1)">
            <summary>
            Borrows a value from the pool and initializes it with the specified value.
            </summary>
        </member>
        <member name="M:Smooth.Pools.PoolWithInitializer`2.BorrowDisposable(`1)">
            <summary>
            Borrows a wrapped value from from the pool and initializes it with the specified value.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Pools.DictionaryPool`2" -->
        <!-- Badly formed XML comment ignored for member "P:Smooth.Pools.DictionaryPool`2.Instance" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Pools.HashSetPool`1" -->
        <!-- Badly formed XML comment ignored for member "P:Smooth.Pools.HashSetPool`1.Instance" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Pools.ListPool`1" -->
        <!-- Badly formed XML comment ignored for member "P:Smooth.Pools.ListPool`1.Instance" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Pools.LinkedListPool`1" -->
        <!-- Badly formed XML comment ignored for member "P:Smooth.Pools.LinkedListPool`1.Instance" -->
        <!-- Badly formed XML comment ignored for member "T:Smooth.Pools.LinkedListNodePool`1" -->
        <!-- Badly formed XML comment ignored for member "P:Smooth.Pools.LinkedListNodePool`1.Instance" -->
        <member name="T:Smooth.Pools.StringBuilderPool">
            <summary>
            Singleton StringBuilder pool.
            </summary>
        </member>
        <member name="P:Smooth.Pools.StringBuilderPool.Instance">
            <summary>
            Singleton StringBuilder pool instance.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Collections.Grouping`2">
            <summary>
            Represents a list of values associated with a key.
            
            The values are stored in Linked form to allow element reordering without the creation of new list nodes.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Grouping`2.key">
            <summary>
            The key associtated with the values.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Grouping`2.values">
            <summary>
            The values associated with the key.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Grouping`2.#ctor(`0,Smooth.Slinq.Collections.LinkedHeadTail{`1})">
            <summary>
            Returns a grouping for the specified key and values.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Collections.Grouping`3">
            <summary>
            Represents a list of values associated with a key.
            
            The values are stored in Slinq form for API simplicity and consistency.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Grouping`3.key">
            <summary>
            The key associtated with the values.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Grouping`3.values">
            <summary>
            The values associated with the key.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Grouping`3.#ctor(`0,Smooth.Slinq.Slinq{`1,`2})">
            <summary>
            Returns a grouping for the specified key and values.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Collections.Grouping">
            <summary>
            Extension methods for performing operations related to groupings without specifying generic parameters.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Grouping.Create``2(``0,Smooth.Slinq.Collections.LinkedHeadTail{``1})">
            <summary>
            Returns a grouping for the specified key and values.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Grouping.Create``3(``0,Smooth.Slinq.Slinq{``1,``2})">
            <summary>
            Returns a grouping for the specified key and values.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Collections.Linked`1">
            <summary>
            Represents a node in a singly linked list.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Linked`1.next">
            <summary>
            The next node in the list.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Linked`1.value">
            <summary>
            The value contained in the node.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked`1.Borrow(`0)">
            <summary>
            Returns a pooled list node with the specified value.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Collections.Linked`1.TrimAndDispose" -->
        <member name="M:Smooth.Slinq.Collections.Linked`1.DisposeInBackground">
            <summary>
            Relinquishes ownership of the node and adds it to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked`1.Dispose">
            <summary>
            Traverses the node list that starts with this node, clears the value of each node, and releases the resulting node list to the pool.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Collections.Linked`2">
            <summary>
            Represents a node in a singly linked list of key, value pairs.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Linked`2.next">
            <summary>
            The next node in the list.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Linked`2.key">
            <summary>
            The key contained in the node.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Linked`2.value">
            <summary>
            The value contained in the node.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked`2.Borrow(`0,`1)">
            <summary>
            Returns a pooled list node with the specified key and value.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Collections.Linked`2.TrimAndDispose" -->
        <member name="M:Smooth.Slinq.Collections.Linked`2.DisposeInBackground">
            <summary>
            Relinquishes ownership of the node and adds it to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked`2.Dispose">
            <summary>
            Traverses the node list that starts with this node, clears the key and value of each node, and releases the resulting node list to the pool.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Collections.LinkedHeadTail`1">
            <summary>
            Represents a singly linked list.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.LinkedHeadTail`1.head">
            <summary>
            The first node in the list.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.LinkedHeadTail`1.tail">
            <summary>
            The last node in the list.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.LinkedHeadTail`1.count">
            <summary>
            The number of elements in the list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.#ctor(`0)">
            <summary>
            Returns a list containing a single node with the specified value.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.#ctor(Smooth.Slinq.Collections.Linked{`0})">
            <summary>
            Returns a list that starts with the specified node.
            
            The constructor will traverse the node links to set the tail and count fields.
            
            If the specified node is null, the resulting list will be empty.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.Append(`0)">
            <summary>
            Appends a pooled node with with specified value to the end of the list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.Append(Smooth.Slinq.Collections.Linked{`0})">
            <summary>
            Appends the specified node to the end of the list.
            
            The node links will be traversed to determine the new tail and count.
            
            If the specified node is null, the list will not be modified.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.Append(Smooth.Slinq.Collections.LinkedHeadTail{`0})">
            <summary>
            Appends the specified list to the end of this list.
            
            This list and the specified list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            
            Calling this method will invalidate the specified list and any variables containing its nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.DisposeInBackground">
            <summary>
            Adds the head of the list to the disposal queue.
            
            The list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.Dispose">
            <summary>
            Releases the head of the list to the node pool.
            
            The list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.SlinqAndKeep">
            <summary>
            Returns a Slinq that enumerates the values contained in the list without reliquishing ownership of the nodes.
            
            The caller of this method is responsible for making sure the returned Slinq is not used after the nodes are modified or returned to the pool.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.SlinqAndKeep(Smooth.Slinq.Context.BacktrackDetector)">
            <summary>
            Returns a Slinq that enumerates the values contained in the list without reliquishing ownership of the nodes.
            
            The caller of this method is responsible for making sure the returned Slinq is not used after the nodes are modified or returned to the pool.
            
            If backtrack detection is enabled, the supplied backtrack detector can be returned to the pool using its TryReleaseShared method to prevent subsequent enumeration of the returned Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.SlinqAndDispose">
            <summary>
            Returns a Slinq that enumerates the values contained in the list.
            
            Ownership of the nodes contained in the list is transferred to the Slinq.  When the Slinq is disposed, the nodes will be added to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.AddTo``1(Smooth.Slinq.Collections.Lookup{``0,`0},Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            Adds the nodes in the list to the specified lookup using the specified key selector.
            
            Ownership of the nodes contained in this list is transerred to the lookup.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.AddTo``2(Smooth.Slinq.Collections.Lookup{``0,`0},Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)">
            <summary>
            Adds the nodes in the list to the specified lookup using the specified key selector.
            
            Ownership of the nodes contained in this list is transerred to the lookup.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.ToLookup``1(Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            Returns a pooled lookup with the default key comparer containing the nodes in the list as partitioned by the specified key selector.
            
            Ownership of the nodes contained in this list is transerred to the lookup.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.ToLookup``1(Smooth.Delegates.DelegateFunc{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns a pooled lookup with the specified key comparer containing the nodes in the list as partitioned by the specified key selector.
            
            Ownership of the nodes contained in this list is transerred to the lookup.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.ToLookup``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)">
            <summary>
            Returns a pooled lookup with the default key comparer containing the nodes in the list as partitioned by the specified key selector.
            
            Ownership of the nodes contained in this list is transerred to the lookup.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`1.ToLookup``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns a pooled lookup with the specified key comparer containing the nodes in the list as partitioned by the specified key selector.
            
            Ownership of the nodes contained in this list is transerred to the lookup.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Collections.LinkedHeadTail`2">
            <summary>
            Represents a singly linked list.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.LinkedHeadTail`2.head">
            <summary>
            The first node in the list.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.LinkedHeadTail`2.tail">
            <summary>
            The last node in the list.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.LinkedHeadTail`2.count">
            <summary>
            The number of elements in the list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.#ctor(`0,`1)">
            <summary>
            Returns a list containing a single node with the specified key and value.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.#ctor(Smooth.Slinq.Collections.Linked{`0,`1})">
            <summary>
            Returns a list that starts with the specified node.
            
            The constructor will traverse the specified node's links to set the tail and count fields.
            
            If the specified node is null, the resulting list will be empty.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.Append(`0,`1)">
            <summary>
            Appends a pooled node with with specified key and value to the end of the list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.Append(Smooth.Slinq.Collections.Linked{`0,`1})">
            <summary>
            Appends the specified node to the end of the list.
            
            The specified node's links will be traversed to determine the new tail and count.
            
            If the specified node is null, the list will not be modified.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.Append(Smooth.Slinq.Collections.LinkedHeadTail{`0,`1})">
            <summary>
            Appends the specified list to the end of this list.
            
            This list and the specified list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            
            Calling this method will invalidate the specified list and any variables containing its nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.DisposeInBackground">
            <summary>
            Adds the head of the list to the disposal queue.
            
            The list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.Dispose">
            <summary>
            Releases the head of the list to the node pool.
            
            The list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.SlinqAndKeep">
            <summary>
            Returns a Slinq that enumerates the values contained in the list without reliquishing ownership of the nodes.
            
            The caller of this method is responsible for making sure the returned Slinq is not used after the nodes are modified or returned to the pool.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.SlinqAndKeep(Smooth.Slinq.Context.BacktrackDetector)">
            <summary>
            Returns a Slinq that enumerates the values contained in the list without reliquishing ownership of the nodes.
            
            The caller of this method is responsible for making sure the returned Slinq is not used after the nodes are modified or returned to the pool.
            
            If backtrack detection is enabled, the supplied backtrack detector can be returned to the pool using its TryReleaseShared method to prevent subsequent enumeration of the returned Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.LinkedHeadTail`2.SlinqAndDispose">
            <summary>
            Returns a Slinq that enumerates the values contained in the list.
            
            Ownership of the nodes contained in the list is transferred to the Slinq.  When the Slinq is disposed, the nodes will be added to the disposal queue.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Slinq.Collections.Linked" -->
        <member name="M:Smooth.Slinq.Collections.Linked.Reverse``1(Smooth.Slinq.Collections.LinkedHeadTail{``0})">
            <summary>
            Reverses the specified list.
            
            The specified list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            
            Calling this method will invalidate the specified list and any variables containing its nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked.Reverse``2(Smooth.Slinq.Collections.LinkedHeadTail{``0,``1})">
            <summary>
            Reverses the specified list.
            
            The specified list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            
            Calling this method will invalidate the specified list and any variables containing its nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked.Sort``1(Smooth.Slinq.Collections.LinkedHeadTail{``0},System.Comparison{``0},System.Boolean)">
             <summary>
             Sorts the specified list using the specified comparison and ordering.
            
             This method uses an introspective merge sort algorithm that will optimally sort rather than split lists with 3 or fewer nodes.
             
             The specified list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
             
             Calling this method will invalidate the specified list and any variables containing its nodes.
             </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked.Sort``2(Smooth.Slinq.Collections.LinkedHeadTail{``0,``1},System.Comparison{``0},System.Boolean)">
             <summary>
             Sorts the specified list using the specified comparison and ordering.
            
             This method uses an introspective merge sort algorithm that will optimally sort rather than split lists with 3 or fewer nodes.
             
             The specified list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
             
             Calling this method will invalidate the specified list and any variables containing its nodes.
             </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked.Merge``1(Smooth.Slinq.Collections.LinkedHeadTail{``0},Smooth.Slinq.Collections.LinkedHeadTail{``0},System.Comparison{``0},System.Boolean)">
            <summary>
            Merges the specified sorted lists using the specified comparison and ordering.  Elements from the left list will appear before elements from the right on equal comparisons.
            
            The specified lists must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            
            Calling this method will invalidate the specified lists and any variables containing their nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked.Merge``2(Smooth.Slinq.Collections.LinkedHeadTail{``0,``1},Smooth.Slinq.Collections.LinkedHeadTail{``0,``1},System.Comparison{``0},System.Boolean)">
            <summary>
            Merges the specified sorted lists using the specified comparison and ordering.  Elements from the left list will appear before elements from the right on equal comparisons.
            
            The specified lists must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            
            Calling this method will invalidate the specified lists and any variables containing their nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked.InsertionSort``1(Smooth.Slinq.Collections.LinkedHeadTail{``0},System.Comparison{``0},System.Boolean)">
            <summary>
            Sorts the specified list using the specified comparison and ordering using an insertion sort algorithm.
            
            The specified list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            
            Calling this method will invalidate the specified list and any variables containing its nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Linked.InsertionSort``2(Smooth.Slinq.Collections.LinkedHeadTail{``0,``1},System.Comparison{``0},System.Boolean)">
            <summary>
            Sorts the specified list using the specified comparison and ordering using an insertion sort algorithm.
            
            The specified list must be well formed when calling this method or the program will enter an invalid state, resulting in unspecified behaviour.
            
            Calling this method will invalidate the specified list and any variables containing its nodes.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Collections.Lookup`2">
            <summary>
            Represents a list of keys each mapped to a list of values.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Lookup`2.keys">
            <summary>
            The list of keys mapped by the lookup.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Collections.Lookup`2.dictionary">
            <summary>
            The dictionary used to map keys to lists of values.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.Borrow(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns a pooled lookup for the specified comparer.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.DisposeInBackground">
            <summary>
            Relinquishes ownership of the lookup and adds it to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.Dispose">
            <summary>
            Releases the lookup and any key and/or value nodes it contains to their respective pools.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.Add(`0,`1)">
            <summary>
            Appends the specified value to the value list for the specified key.  If the key was previously unmapped it is appended to the key list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.Add(`0,Smooth.Slinq.Collections.Linked{`1})">
            <summary>
            Appends the specified value to the value list for the specified key.  If the key was previously unmapped it is appended to the key list.
            
            Calling this method transfers ownership of the specified node and any linked nodes to the lookup.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.Add(`0,Smooth.Slinq.Collections.LinkedHeadTail{`1})">
            <summary>
            Appends the specified list to the value list for the specified key.  If the key was previously unmapped it is appended to the key list.
            
            Calling this method transfers ownership of the nodes in the specified list to the lookup.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.GetValues(`0)">
            <summary>
            Returns the list of values for the specified key, without transfer of ownership.
            
            The caller of this method is responsible for mananging the scope of the returned nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.RemoveValues(`0)">
            <summary>
            Returns the list of values for the specified key with ownership of the nodes transferred to the caller.
            
            The caller of this method is responsible for the disposal of the returned nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.SortKeys(System.Comparison{`0},System.Boolean)">
            <summary>
            Sorts the lookup's keys using the specified comparison and ordering.
            
            This method uses an introspective merge sort algorithm that will optimally sort rather than split lists with 3 or fewer nodes.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.FlattenAndDispose">
            <summary>
            Returns a list of all the values contained in this lookup and adds the lookup to the disposal queue.
            
            Items in the list will be ordered based on the ordering of the key list, then by the position within value list for the item's key.
            
            Ownership of the returned nodes is transferred to the caller, who is responsible for their disposal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.SlinqAndKeep">
            <summary>
            Returns a Slinq that enumerates the key, value groupings contained in the lookup, with the values returned in Slinq form.
            
            Ownership of the lookup and any values it contains is retained by the caller.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.SlinqAndDispose">
            <summary>
            Returns a Slinq that enumerates the key, value groupings contained in the lookup, with the values returned in Slinq form.
            
            As the groupings are enumerated, ownership of the values in each grouping is transferred to the Slinq contained in the grouping.
            
            When the enumeration is complete, the lookup and any unenumerated values it contains are added to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.SlinqLinkedAndKeep">
            <summary>
            Returns a Slinq that enumerates the key, value groupings contained in the lookup, with the values returned in Linked form.
            
            Ownership of the lookup and any values it contains is retained by the caller.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.SlinqLinkedAndDispose">
            <summary>
            Returns a Slinq that enumerates the key, value groupings contained in the lookup, with the values returned in Linked form.
            
            As the groupings are enumerated, ownership of the values in each grouping is transferred to the owner of the grouping, who is responsible for their disposal.
            
            When the enumeration is complete, the lookup and any unenumerated values it contains are added to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.GroupJoinAndKeep``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,`0},Smooth.Delegates.DelegateFunc{``1,Smooth.Slinq.Slinq{`1,Smooth.Slinq.Context.LinkedContext{`1}},``0})">
            <summary>
            Returns a Slinq that enumerates a group join of the lookup with the specified Slinq using the specified selectors.
            
            Ownership of the lookup and any values it contains is retained by the caller.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.GroupJoinAndKeep``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,`0},Smooth.Delegates.DelegateFunc{``1,Smooth.Slinq.Slinq{`1,Smooth.Slinq.Context.LinkedContext{`1}},``3,``0},``3)">
            <summary>
            Returns a Slinq that enumerates a group join of the lookup with the specified Slinq using the specified selectors.
            
            Ownership of the lookup and any values it contains is retained by the caller.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.GroupJoinAndDispose``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,`0},Smooth.Delegates.DelegateFunc{``1,Smooth.Slinq.Slinq{`1,Smooth.Slinq.Context.LinkedContext{`1}},``0})">
            <summary>
            Returns a Slinq that enumerates a group join of the lookup with the specified Slinq using the specified selectors.
            
            When the enumeration is complete, the lookup and any values it contains are added to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.GroupJoinAndDispose``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,`0},Smooth.Delegates.DelegateFunc{``1,Smooth.Slinq.Slinq{`1,Smooth.Slinq.Context.LinkedContext{`1}},``3,``0},``3)">
            <summary>
            Returns a Slinq that enumerates a group join of the lookup with the specified Slinq using the specified selectors.
            
            When the enumeration is complete, the lookup and any values it contains are added to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.JoinAndKeep``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,`0},Smooth.Delegates.DelegateFunc{``1,`1,``0})">
            <summary>
            Returns a Slinq that enumerates an inner join of the lookup with the specified Slinq using the specified selectors.
            
            Ownership of the lookup and any values it contains is retained by the caller.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.JoinAndKeep``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,`0},Smooth.Delegates.DelegateFunc{``1,`1,``3,``0},``3)">
            <summary>
            Returns a Slinq that enumerates an inner join of the lookup with the specified Slinq using the specified selectors.
            
            Ownership of the lookup and any values it contains is retained by the caller.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.JoinAndDispose``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,`0},Smooth.Delegates.DelegateFunc{``1,`1,``0})">
            <summary>
            Returns a Slinq that enumerates an inner join of the lookup with the specified Slinq using the specified selectors.
            
            When the enumeration is complete, the lookup and any values it contains are added to the disposal queue.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Collections.Lookup`2.JoinAndDispose``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,`0},Smooth.Delegates.DelegateFunc{``1,`1,``3,``0},``3)">
            <summary>
            Returns a Slinq that enumerates an inner join of the lookup with the specified Slinq using the specified selectors.
            
            When the enumeration is complete, the lookup and any values it contains are added to the disposal queue.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Context.BacktrackDetector">
            <summary>
            Used to find backtracking Slinq usage.
            
            If DETECT_BACKTRACK is defined, backtrack detectors will lock a reference context and test the backtrack state on every Slinq operation.
            This will severely reduce performance and should only be used for debugging purposes.
            
            If DETECT_BACKTRACK is not defined, detection operations will not be compiled into the application.
            
            Note: Backtrack detection does not work reliably across multiple threads.
            If pooled objects are shared or passed between threads, external locking and/or ownership management is the repsonsibility of the user.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Smooth.Slinq.Slinq`2" -->
        <member name="F:Smooth.Slinq.Slinq`2.skip">
            <summary>
            Part of the internal API.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Slinq`2.remove">
            <summary>
            Part of the internal API.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Slinq`2.dispose">
            <summary>
            Part of the internal API.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Slinq`2.context">
            <summary>
            Part of the internal API.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.#ctor(Smooth.Slinq.Context.Mutator{`0,`1},Smooth.Slinq.Context.Mutator{`0,`1},Smooth.Slinq.Context.Mutator{`0,`1},`1)">
            <summary>
            Part of the internal API.
            </summary>
        </member>
        <member name="F:Smooth.Slinq.Slinq`2.current">
            <summary>
            Either a Some option containing the current value of the enumeration, or a None option if the enumeration is complete.
            
            Note: This is a public field for reasons concerning the internal API and should not be modified by user code.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Skip">
            <summary>
            Moves the Slinq to the next element in the enumeration.  If the Slinq is empty this will have no effect.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SkipAndReturn">
            <summary>
            Moves the Slinq to the next element in the enumeration and returns the Slinq.  If the Slinq is empty this will have no effect.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Remove">
            <summary>
            Removes the current element from the underlying sequence and moves the Slinq to the next element in the enumeration.  If the Slinq is empty this will have no effect.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveAndReturn">
            <summary>
            Removes the current element from the underlying sequence, moves the Slinq to the next element in the enumeration, and returns the Slinq.  If the Slinq is empty this will have no effect.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Dispose">
            <summary>
            Sets the current value of the Slinq to None and releases any shared resources held by the Slinq.  If the Slinq is empty this will have no effect.
            
            Slinqs are automatically disposed when they become empty, but if you are done with a Slinq that still contains values, you must call Dispose to ensure the release and/or disposal of any resources held by the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SkipAll">
            <summary>
            Enumerates the remaining elements of the Slinq.  Useful if you want to force execution of the underlying chain.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Skip(System.Int32)">
            <summary>
            Enumerates up to the specified number of elements from the Slinq.
            
            If count is greater than or equal to the number of elements remaining, all the remaining elements will be enumerated.
            
            If count is less than or equal to zero, no elements will be enumerated.
            
            After perfoming this operation, the Slinq will be positioned count elements further along the enumeration.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SkipWhile(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Enumerates elements from the Slinq while the specified predicate returns true.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SkipWhile``1(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0)">
            <summary>
            Enumerates elements from the Slinq while the specified predicate returns true.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SkipWhile``1(``0,Smooth.Delegates.DelegateFunc{``0,`0,Smooth.Algebraics.Option{``0}})">
            <summary>
            Aggregates elements from the Slinq while the specified selector returns a Some option.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the selector returns None.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SkipWhile``2(``0,Smooth.Delegates.DelegateFunc{``0,`0,``1,Smooth.Algebraics.Option{``0}},``1)">
            <summary>
            Aggregates elements from the Slinq while the specified selector returns a Some option.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the selector returns None.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveAll">
            <summary>
            Enumerates the remaining elements from the Slinq, removes them from the underlying sequence, and returns the number of elements removed.
            
            This operation will consume and dispose the Slinq.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveAll(Smooth.Delegates.DelegateAction{`0})">
            <summary>
            Enumerates the remaining elements from the Slinq, removes them from the underlying sequence, and returns the number of elements removed.
            
            After an element is removed the specified then action will be called with the element.
            
            This operation will consume and dispose the Slinq.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveAll``1(Smooth.Delegates.DelegateAction{`0,``0},``0)">
            <summary>
            Enumerates the remaining elements from the Slinq, removes them from the underlying sequence, and returns the number of elements removed.
            
            After an element is removed the specified then action will be called with the element and the specified then parameter.
            
            This operation will consume and dispose the Slinq.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Remove(System.Int32)">
            <summary>
            Enumerates up to the specified number of elements from the Slinq and removes them from the underlying sequence.
            
            If count is greater than or equal to the number of elements remaining, all the remaining elements will be removed.
            
            If count is less than or equal to zero, no elements will be removed.
            
            After perfoming this operation, the Slinq will be positioned count elements further along the enumeration.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Remove(System.Int32,Smooth.Delegates.DelegateAction{`0})">
            <summary>
            Enumerates up to the specified number of elements from the Slinq and removes them from the underlying sequence.
            
            After an element is removed the specified then action will be called with the element.
            
            If count is greater than or equal to the number of elements remaining, all the remaining elements will be removed.
            
            If count is less than or equal to zero, no elements will be removed.
            
            After perfoming this operation, the Slinq will be positioned count elements further along the enumeration.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Remove``1(System.Int32,Smooth.Delegates.DelegateAction{`0,``0},``0)">
            <summary>
            Enumerates up to the specified number of elements from the Slinq and removes them from the underlying sequence.
            
            After an element is removed the specified then action will be called with the element and the specified then parameter.
            
            If count is greater than or equal to the number of elements remaining, all the remaining elements will be removed.
            
            If count is less than or equal to zero, no elements will be removed.
            
            After perfoming this operation, the Slinq will be positioned count elements further along the enumeration.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Enumerates elements from the Slinq and removes them from the underlying sequence while the specified predicate returns true.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile(Smooth.Delegates.DelegateFunc{`0,System.Boolean},Smooth.Delegates.DelegateAction{`0})">
            <summary>
            Enumerates elements from the Slinq and removes them from the underlying sequence while the specified predicate returns true.
            
            After an element is removed the specified then action will be called with the element.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``1(Smooth.Delegates.DelegateFunc{`0,System.Boolean},Smooth.Delegates.DelegateAction{`0,``0},``0)">
            <summary>
            Enumerates elements from the Slinq and removes them from the underlying sequence while the specified predicate returns true.
            
            After an element is removed the specified then action will be called with the element and the specifed then parameter.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``1(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0)">
            <summary>
            Enumerates elements from the Slinq and removes them from the underlying sequence while the specified predicate returns true.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``1(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0,Smooth.Delegates.DelegateAction{`0})">
            <summary>
            Enumerates elements from the Slinq and removes them from the underlying sequence while the specified predicate returns true.
            
            After an element is removed the specified then action will be called with the element.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``2(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0,Smooth.Delegates.DelegateAction{`0,``1},``1)">
            <summary>
            Enumerates elements from the Slinq and removes them from the underlying sequence while the specified predicate returns true.
            
            After an element is removed the specified then action will be called with the element and the specified then parameter.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``1(``0,Smooth.Delegates.DelegateFunc{``0,`0,Smooth.Algebraics.Option{``0}})">
            <summary>
            Aggregates elements from the Slinq and removes them from the underlying sequence while the specified selector returns a Some option.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``1(``0,Smooth.Delegates.DelegateFunc{``0,`0,Smooth.Algebraics.Option{``0}},Smooth.Delegates.DelegateAction{`0})">
            <summary>
            Aggregates elements from the Slinq and removes them from the underlying sequence while the specified selector returns a Some option.
            
            After an element is removed the specified then action will be called with the element.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``2(``0,Smooth.Delegates.DelegateFunc{``0,`0,Smooth.Algebraics.Option{``0}},Smooth.Delegates.DelegateAction{`0,``1},``1)">
            <summary>
            Aggregates elements from the Slinq and removes them from the underlying sequence while the specified selector returns a Some option.
            
            After an element is removed the specified then action will be called with the element and the specified then parameter.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the predicate returns false.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``2(``0,Smooth.Delegates.DelegateFunc{``0,`0,``1,Smooth.Algebraics.Option{``0}},``1)">
            <summary>
            Aggregates elements from the Slinq and removes them from the underlying sequence while the specified selector returns a Some option.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the selector returns None.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``2(``0,Smooth.Delegates.DelegateFunc{``0,`0,``1,Smooth.Algebraics.Option{``0}},``1,Smooth.Delegates.DelegateAction{`0})">
            <summary>
            Aggregates elements from the Slinq and removes them from the underlying sequence while the specified selector returns a Some option.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the selector returns None.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.RemoveWhile``3(``0,Smooth.Delegates.DelegateFunc{``0,`0,``1,Smooth.Algebraics.Option{``0}},``1,Smooth.Delegates.DelegateAction{`0,``2},``2)">
            <summary>
            Aggregates elements from the Slinq and removes them from the underlying sequence while the specified selector returns a Some option.
            
            After perfoming this operation, the Slinq will be positioned on the first element for which the selector returns None.
            </summary>
            <exception cref="T:System.NotSupportedException">The Slinq or an underlying Slinq in the chain does not support element removal.</exception>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Aggregate(Smooth.Delegates.DelegateFunc{`0,`0,`0})">
            <summary>
            Analog to Enumerable.Aggregate().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AggregateOrNone(Smooth.Delegates.DelegateFunc{`0,`0,`0})">
            <summary>
            Analog to Enumerable.Aggregate(), but returns an option rather than throwing an exception if the Slinq is empty.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AggregateOrNone``1(Smooth.Delegates.DelegateFunc{`0,`0,``0,`0},``0)">
            <summary>
            Analog to Enumerable.Aggregate(), but returns an option rather than throwing an exception if the Slinq is empty.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Aggregate``1(``0,Smooth.Delegates.DelegateFunc{``0,`0,``0})">
            <summary>
            Analog to Enumerable.Aggregate().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Aggregate``2(``0,Smooth.Delegates.DelegateFunc{``0,`0,``0},Smooth.Delegates.DelegateFunc{``0,``1})">
            <summary>
            Analog to Enumerable.Aggregate().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Aggregate``2(``0,Smooth.Delegates.DelegateFunc{``0,`0,``1,``0},``1)">
            <summary>
            Analog to Enumerable.Aggregate().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AggregateWhile``1(``0,Smooth.Delegates.DelegateFunc{``0,`0,Smooth.Algebraics.Option{``0}})">
            <summary>
            Aggregates elements from the Slinq while the selector returns a Some option.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AggregateWhile``2(``0,Smooth.Delegates.DelegateFunc{``0,`0,``1,Smooth.Algebraics.Option{``0}},``1)">
            <summary>
            Aggregates elements from the Slinq while the selector returns a Some option.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.All(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Analog to Enumerable.All().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.All``1(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0)">
            <summary>
            Analog to Enumerable.All().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Any">
            <summary>
            Analog to Enumerable.Any().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Any(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Analog to Enumerable.Any().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Any``1(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0)">
            <summary>
            Analog to Enumerable.Any().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Contains(`0)">
            <summary>
            Analog to Enumerable.Contains().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Contains(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Analog to Enumerable.Contains().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Count">
            <summary>
            Analog to Enumerable.Count().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ElementAt(System.Int32)">
            <summary>
            Analog to Enumerable.ElementAt().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ElementAtOrDefault(System.Int32)">
            <summary>
            Analog to Enumerable.ElementAtOrDefault().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ElementAtOrNone(System.Int32)">
            <summary>
            Analog to Enumerable.ElementAt(), but returns an option rather than throwing an exception if the element does not exist.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.First">
            <summary>
            Analog to Enumerable.First().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.First(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Analog to Enumerable.First().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.FirstOrDefault">
            <summary>
            Analog to Enumerable.FirstOrDefault().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.FirstOrDefault(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Analog to Enumerable.FirstOrDefault().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.FirstOrNone">
            <summary>
            Analog to Enumerable.First(), but returns an option rather than throwing an exception if the Slinq is empty.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.FirstOrNone(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Analog to Enumerable.First(), but returns an option rather than throwing an exception if the Slinq is empty.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.FirstOrNone``1(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0)">
            <summary>
            Analog to Enumerable.First(), but returns an option rather than throwing an exception if the Slinq is empty.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ForEach(Smooth.Delegates.DelegateAction{`0})">
            <summary>
            Performs the specified action on each remaining element in the Slinq.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ForEach``1(Smooth.Delegates.DelegateAction{`0,``0},``0)">
            <summary>
            Performs the specified action on each remaining element in the Slinq with the specified parameter.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Last">
            <summary>
            Analog to Enumerable.Last().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Last(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Analog to Enumerable.Last().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.LastOrDefault">
            <summary>
            Analog to Enumerable.LastOrDefault().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.LastOrDefault(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Analog to Enumerable.LastOrDefault().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.LastOrNone">
            <summary>
            Analog to Enumerable.Last(), but returns an option rather than throwing an exception if the Slinq is empty.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.LastOrNone(Smooth.Delegates.DelegateFunc{`0,System.Boolean})">
            <summary>
            Analog to Enumerable.Last(), but returns an option rather than throwing an exception if the Slinq is empty.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.LastOrNone``1(Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean},``0)">
            <summary>
            Analog to Enumerable.Last(), but returns an option rather than throwing an exception if the Slinq is empty.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Max">
            <summary>
            Analog to Enumerable.Max().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MaxOrNone">
            <summary>
            Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MaxOrNone(System.Collections.Generic.IComparer{`0})">
            <summary>
            Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MaxOrNone(System.Comparison{`0})">
            <summary>
            Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MaxOrNone``1(Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MaxOrNone``1(Smooth.Delegates.DelegateFunc{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MaxOrNone``1(Smooth.Delegates.DelegateFunc{`0,``0},System.Comparison{``0})">
            <summary>
            Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MaxOrNone``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)">
            <summary>
            Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MaxOrNone``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MaxOrNone``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,System.Comparison{``0})">
            <summary>
            Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Min">
            <summary>
            Analog to Enumerable.Min().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MinOrNone">
            <summary>
            Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Min(System.Collections.Generic.IComparer{`0})">
            <summary>
            Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MinOrNone(System.Comparison{`0})">
            <summary>
            Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MinOrNone``1(Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MinOrNone``1(Smooth.Delegates.DelegateFunc{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MinOrNone``1(Smooth.Delegates.DelegateFunc{`0,``0},System.Comparison{``0})">
            <summary>
            Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MinOrNone``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)">
            <summary>
            Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MinOrNone``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.MinOrNone``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,System.Comparison{``0})">
            <summary>
            Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the Slinq is empty and T is a value type.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SequenceEqual``1(Smooth.Slinq.Slinq{`0,``0})">
            <summary>
            Analog to Enumerable.SequenceEqual().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SequenceEqual``1(Smooth.Slinq.Slinq{`0,``0},System.Collections.Generic.EqualityComparer{`0})">
            <summary>
            Analog to Enumerable.SequenceEqual().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SequenceEqual``2(Smooth.Slinq.Slinq{``0,``1},Smooth.Delegates.DelegateFunc{`0,``0,System.Boolean})">
            <summary>
            Analog to Enumerable.SequenceEqual().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.Single">
            <summary>
            Analog to Enumerable.Single().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SingleOrDefault">
            <summary>
            Analog to Enumerable.SingleOrDefault().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SingleOrNone">
            <summary>
            Analog to Enumerable.Single(), but returns an option rather than throwing an exception if the Slinq is empty or contains more than one element.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.SplitRight(System.Int32)">
            <summary>
            Splits the remaining elements into a pair of lists, with the first list containing elements starting from the current position of the Slinq and the second list containing up to the last count elements from the end of the Slinq.
            
            If count is greater than or equal to the number of elements remaining, the first list will be empty and the second list will contain all the remaining elements.
            
            If count is less than or equal to zero, the first list will contain all the remaining elements and the second list will be empty.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AddTo``1(``0)">
            <summary>
            Adds the remaining elements in the Slinq to the specified collection and returns the collection.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AddTo``1(Smooth.Dispose.Disposable{``0})">
            <summary>
            Adds the remaining elements in the Slinq to the specified collection and returns the collection.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AddTo``2(``1,Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            Adds the remaining elements in the Slinq to the specified collection using the specified selector and returns the collection.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AddTo``2(Smooth.Dispose.Disposable{``1},Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            Adds the remaining elements in the Slinq to the specified collection using the specified selector and returns the collection.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AddTo``3(``1,Smooth.Delegates.DelegateFunc{`0,``2,``0},``2)">
            <summary>
            Adds the remaining elements in the Slinq to the specified collection using the specified selector and returns the collection.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.AddTo``3(Smooth.Dispose.Disposable{``1},Smooth.Delegates.DelegateFunc{`0,``2,``0},``2)">
            <summary>
            Adds the remaining elements in the Slinq to the specified collection using the specified selector and returns the collection.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinq`2.AddTo(Smooth.Slinq.Collections.LinkedHeadTail{`0})" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinq`2.AddToReverse(Smooth.Slinq.Collections.LinkedHeadTail{`0})" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinq`2.AddTo``1(Smooth.Slinq.Collections.LinkedHeadTail{``0,`0},Smooth.Delegates.DelegateFunc{`0,``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinq`2.AddTo``2(Smooth.Slinq.Collections.LinkedHeadTail{``0,`0},Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinq`2.AddToReverse``1(Smooth.Slinq.Collections.LinkedHeadTail{``0,`0},Smooth.Delegates.DelegateFunc{`0,``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinq`2.AddToReverse``2(Smooth.Slinq.Collections.LinkedHeadTail{``0,`0},Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinq`2.AddTo``1(Smooth.Slinq.Collections.Lookup{``0,`0},Smooth.Delegates.DelegateFunc{`0,``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinq`2.AddTo``2(Smooth.Slinq.Collections.Lookup{``0,`0},Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)" -->
        <member name="M:Smooth.Slinq.Slinq`2.ToLinked">
            <summary>
            Converts the Slinq into a singly linked list.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ToLinkedReverse">
            <summary>
            Converts the Slinq into an order-reversed singly linked list.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ToLinked``1(Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            Converts the Slinq into a singly linked key, value list using the specified key selector.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ToLinked``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)">
            <summary>
            Converts the Slinq into a singly linked key, value list using the specified key selector.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ToLinkedReverse``1(Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            Converts the Slinq into an order-reversed singly linked key, value list using the specified key selector.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ToLinkedReverse``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)">
            <summary>
            Converts the Slinq into an order-reversed singly linked key, value list using the specified key selector.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ToLookup``1(Smooth.Delegates.DelegateFunc{`0,``0})">
            <summary>
            Converts the Slinq into a lookup using the specified key selector.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ToLookup``1(Smooth.Delegates.DelegateFunc{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Converts the Slinq into a lookup using the specified key selector and equality comparer.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ToLookup``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1)">
            <summary>
            Converts the Slinq into a lookup using the specified key selector and equality comparer.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq`2.ToLookup``2(Smooth.Delegates.DelegateFunc{`0,``1,``0},``1,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Converts the Slinq into a lookup using the specified key selector and equality comparer.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinq`2.ToList" -->
        <member name="T:Smooth.Slinq.Slinq">
            <summary>
            Provides methods for the creation of chained Slinqs as well as various type specific Slinq comprehensions.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.AggregateRunning``3(Smooth.Slinq.Slinq{``1,``2},``0,Smooth.Delegates.DelegateFunc{``0,``1,``0})">
            <summary>
            Returns a chained Slinq that performs a running aggegatation over the specified Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.AggregateRunning``4(Smooth.Slinq.Slinq{``1,``2},``0,Smooth.Delegates.DelegateFunc{``0,``1,``3,``0},``3)">
            <summary>
            Returns a chained Slinq that performs a running aggegatation over the specified Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Concat``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Slinq.Slinq{``1,``0})">
            <summary>
            Analog to Enumerable.Concat().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.DefaultIfEmpty``2(Smooth.Slinq.Slinq{``0,``1})">
            <summary>
            Analog to Enumerable.DefaultIfEmpty().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.DefaultIfEmpty``2(Smooth.Slinq.Slinq{``0,``1},``0)">
            <summary>
            Analog to Enumerable.DefaultIfEmpty().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Distinct``2(Smooth.Slinq.Slinq{``0,``1})">
            <summary>
            Analog to Enumerable.Distinct().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Distinct``2(Smooth.Slinq.Slinq{``0,``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.Distinct().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Distinct``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0})">
            <summary>
            Analog to Enumerable.Distinct().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Distinct``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.Distinct().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Distinct``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3)">
            <summary>
            Analog to Enumerable.Distinct().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Distinct``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.Distinct().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Except``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Slinq.Slinq{``1,``0})">
            <summary>
            Analog to Enumerable.Except().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Except``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Slinq.Slinq{``1,``0},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Analog to Enumerable.Except().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Except``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``0})">
            <summary>
            Analog to Enumerable.Except().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Except``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.Except().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Except``5(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``4,``0},``4)">
            <summary>
            Analog to Enumerable.Except().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Except``5(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``4,``0},``4,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.Except().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Flatten``3(Smooth.Slinq.Slinq{Smooth.Slinq.Slinq{``0,``1},``2})">
            <summary>
            Returns a chained Slinq that enumerates over each of the nested elements in the specified Slinq.
            
            See: SelectMany().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Flatten``2(Smooth.Slinq.Slinq{Smooth.Algebraics.Option{``0},``1})">
            <summary>
            Returns a chained Slinq that enumerates over each of the nested elements in the specified Slinq.
            
            See: SelectMany().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.GroupBy``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0})">
            <summary>
            Analog to Enumerable.GroupBy().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.GroupBy``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.GroupBy().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.GroupBy``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3)">
            <summary>
            Analog to Enumerable.GroupBy().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.GroupBy``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.GroupBy().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.GroupJoin``6(Smooth.Slinq.Slinq{``4,``5},Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``4,``1},Smooth.Delegates.DelegateFunc{``2,``1},Smooth.Delegates.DelegateFunc{``4,Smooth.Slinq.Slinq{``2,Smooth.Slinq.Context.LinkedContext{``2}},``0})">
            <summary>
            Analog to Enumerable.GroupJoin(), with removal operations chained to the outer Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.GroupJoin``6(Smooth.Slinq.Slinq{``4,``5},Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``4,``1},Smooth.Delegates.DelegateFunc{``2,``1},Smooth.Delegates.DelegateFunc{``4,Smooth.Slinq.Slinq{``2,Smooth.Slinq.Context.LinkedContext{``2}},``0},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Analog to Enumerable.GroupJoin(), with removal operations chained to the outer Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.GroupJoin``7(Smooth.Slinq.Slinq{``4,``5},Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``4,``6,``1},Smooth.Delegates.DelegateFunc{``2,``6,``1},Smooth.Delegates.DelegateFunc{``4,Smooth.Slinq.Slinq{``2,Smooth.Slinq.Context.LinkedContext{``2}},``6,``0},``6)">
            <summary>
            Analog to Enumerable.GroupJoin(), with removal operations chained to the outer Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.GroupJoin``7(Smooth.Slinq.Slinq{``4,``5},Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``4,``6,``1},Smooth.Delegates.DelegateFunc{``2,``6,``1},Smooth.Delegates.DelegateFunc{``4,Smooth.Slinq.Slinq{``2,Smooth.Slinq.Context.LinkedContext{``2}},``6,``0},``6,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Analog to Enumerable.GroupJoin(), with removal operations chained to the outer Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Intersect``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Slinq.Slinq{``1,``0})">
            <summary>
            Analog to Enumerable.Intersect().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Intersect``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Slinq.Slinq{``1,``0},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Analog to Enumerable.Intersect().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Intersect``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``0})">
            <summary>
            Analog to Enumerable.Intersect().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Intersect``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.Intersect().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Intersect``5(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``4,``0},``4)">
            <summary>
            Analog to Enumerable.Intersect().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Intersect``5(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``4,``0},``4,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.Intersect().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Join``6(Smooth.Slinq.Slinq{``4,``5},Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``4,``1},Smooth.Delegates.DelegateFunc{``2,``1},Smooth.Delegates.DelegateFunc{``4,``2,``0})">
            <summary>
            Analog to Enumerable.Join(), with removal operations chained to the outer Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Join``6(Smooth.Slinq.Slinq{``4,``5},Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``4,``1},Smooth.Delegates.DelegateFunc{``2,``1},Smooth.Delegates.DelegateFunc{``4,``2,``0},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Analog to Enumerable.Join(), with removal operations chained to the outer Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Join``7(Smooth.Slinq.Slinq{``4,``5},Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``4,``6,``1},Smooth.Delegates.DelegateFunc{``2,``6,``1},Smooth.Delegates.DelegateFunc{``4,``2,``6,``0},``6)">
            <summary>
            Analog to Enumerable.Join(), with removal operations chained to the outer Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Join``7(Smooth.Slinq.Slinq{``4,``5},Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``4,``6,``1},Smooth.Delegates.DelegateFunc{``2,``6,``1},Smooth.Delegates.DelegateFunc{``4,``2,``6,``0},``6,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Analog to Enumerable.Join(), with removal operations chained to the outer Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``2(Smooth.Slinq.Slinq{``0,``1})">
            <summary>
            Analog to Enumerable.OrderBy().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``2(Smooth.Slinq.Slinq{``0,``1},System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.OrderBy().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``2(Smooth.Slinq.Slinq{``0,``1},System.Comparison{``0})">
            <summary>
            Analog to Enumerable.OrderBy().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByDescending``2(Smooth.Slinq.Slinq{``0,``1})">
            <summary>
            Analog to Enumerable.OrderByDescending().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByDescending``2(Smooth.Slinq.Slinq{``0,``1},System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.OrderByDescending().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByDescending``2(Smooth.Slinq.Slinq{``0,``1},System.Comparison{``0})">
            <summary>
            Analog to Enumerable.OrderByDescending().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``2(Smooth.Slinq.Slinq{``0,``1},System.Comparison{``0},System.Boolean)">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq as ordered by the specified key selector, comparison, and ordering.
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0})">
            <summary>
            Analog to Enumerable.OrderBy().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.OrderBy().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Comparison{``0})">
            <summary>
            Analog to Enumerable.OrderBy().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByDescending``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0})">
            <summary>
            Analog to Enumerable.OrderByDescending().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByDescending``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.OrderByDescending().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByDescending``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Comparison{``0})">
            <summary>
            Analog to Enumerable.OrderByDescending().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Comparison{``0},System.Boolean)">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq as ordered by the specified key selector, comparison, and ordering.
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3)">
            <summary>
            Analog to Enumerable.OrderBy().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.OrderBy().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Comparison{``0})">
            <summary>
            Analog to Enumerable.OrderBy().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByDescending``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3)">
            <summary>
            Analog to Enumerable.OrderByDescending().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByDescending``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Collections.Generic.IComparer{``0})">
            <summary>
            Analog to Enumerable.OrderByDescending().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByDescending``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Comparison{``0})">
            <summary>
            Analog to Enumerable.OrderByDescending().
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderBy``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Comparison{``0},System.Boolean)">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq as ordered by the specified key selector, comparison, and ordering.
            
            This method uses a linked list merge sort algorithm and has O(n) space complexity and O(n Log n) average and worst case time complexity.
            
            Note: The Slinq API does not provide methods for ThenBy() orderings, to sort by multiple values in succession you should supply a composite key and/or comparision.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroup``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and the default equality comparer for K, with the groups ordered by the default sort order comparer for K.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroup``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and equality comparer, with the groups ordered by the specified sort order comparer.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroup``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Collections.Generic.IEqualityComparer{``0},System.Comparison{``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and equality comparer, with the groups ordered by the specified comparison.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroupDescending``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and the default equality comparer for K, with the groups ordered descendingly by the default sort order comparer for K.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroupDescending``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and equality comparer, with the groups ordered descendingly by the specified sort order comparer.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroupDescending``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0},System.Collections.Generic.IEqualityComparer{``0},System.Comparison{``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and equality comparer, with the groups ordered descendingly by the specified comparison.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroup``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3)">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and the default equality comparer for K, with the groups ordered by the default sort order comparer for K.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroup``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and equality comparer, with the groups ordered by the specified sort order comparer.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroup``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Collections.Generic.IEqualityComparer{``0},System.Comparison{``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and equality comparer, with the groups ordered by the specified comparison.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroupDescending``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3)">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and the default equality comparer for K, with the groups ordered descendingly by the default sort order comparer for K.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroupDescending``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and equality comparer, with the groups ordered descendingly by the specified sort order comparer.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.OrderByGroupDescending``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3,System.Collections.Generic.IEqualityComparer{``0},System.Comparison{``0})">
            <summary>
            Returns a chained Slinq that enumerates the elements of the specified Slinq ordered by grouping the elements according to the specified key selector and equality comparer, with the groups ordered descendingly by the specified comparison.
            
            This method has O(n + k) space compexity and O(n + k Log k) time complexity where n is the number of elements and k is the number of keys.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Reverse``2(Smooth.Slinq.Slinq{``0,``1})">
            <summary>
            Analog to Enumerable.Reverse().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Select``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``0})">
            <summary>
            Analog to Enumerable.Select().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Select``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,``0},``3)">
            <summary>
            Analog to Enumerable.Select().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.SelectMany``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``2,Smooth.Slinq.Slinq{``0,``1}})">
            <summary>
            Analog to Enumerable.SelectMany().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.SelectMany``5(Smooth.Slinq.Slinq{``2,``3},Smooth.Delegates.DelegateFunc{``2,``4,Smooth.Slinq.Slinq{``0,``1}},``4)">
            <summary>
            Analog to Enumerable.SelectMany().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.SelectMany``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,Smooth.Algebraics.Option{``0}})">
            <summary>
            Analog to Enumerable.SelectMany().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.SelectMany``4(Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``1,``3,Smooth.Algebraics.Option{``0}},``3)">
            <summary>
            Analog to Enumerable.SelectMany().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Take``2(Smooth.Slinq.Slinq{``0,``1},System.Int32)">
            <summary>
            Analog to Enumerable.Take().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.TakeRight``2(Smooth.Slinq.Slinq{``0,``1},System.Int32)">
            <summary>
            Returns a chained Slinq that contains up to count elements from the end of the specified Slinq.
            
            If count is greater than or equal to the number of elements remaining, the returned Slinq will contain all the remaining elements.
            
            If count is less than or equal to zero, the returned Slinq will be empty.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.TakeWhile``2(Smooth.Slinq.Slinq{``0,``1},Smooth.Delegates.DelegateFunc{``0,System.Boolean})">
            <summary>
            Analog to Enumerable.TakeWhile().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.TakeWhile``3(Smooth.Slinq.Slinq{``0,``1},Smooth.Delegates.DelegateFunc{``0,``2,System.Boolean},``2)">
            <summary>
            Analog to Enumerable.TakeWhile().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Where``2(Smooth.Slinq.Slinq{``0,``1},Smooth.Delegates.DelegateFunc{``0,System.Boolean})">
            <summary>
            Analog to Enumerable.Where().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Where``3(Smooth.Slinq.Slinq{``0,``1},Smooth.Delegates.DelegateFunc{``0,``2,System.Boolean},``2)">
            <summary>
            Analog to Enumerable.Where().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Union``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Slinq.Slinq{``1,``0})">
            <summary>
            Analog to Enumerable.Union().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Union``3(Smooth.Slinq.Slinq{``1,``2},Smooth.Slinq.Slinq{``1,``0},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Analog to Enumerable.Union().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Union``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``0})">
            <summary>
            Analog to Enumerable.Union().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Union``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.Union().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Union``5(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``4,``0},``4)">
            <summary>
            Analog to Enumerable.Union().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Union``5(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``2,``1},Smooth.Delegates.DelegateFunc{``2,``4,``0},``4,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Analog to Enumerable.Union().
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Zip``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``0,``1})">
            <summary>
            Analog to Enumerable.Zip() that combines elements into tuples and chains removal operations to the left Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Zip``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``0,``1},Smooth.Slinq.Context.ZipRemoveFlags)">
            <summary>
            Analog to Enumerable.Zip() that combines elements into tuples and chains removal operations to the the specified Slinq(s).
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Zip``5(Smooth.Slinq.Slinq{``3,``4},Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``3,``1,``0})">
            <summary>
            Analog to Enumerable.Zip() that chains removal operations to the left Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Zip``5(Smooth.Slinq.Slinq{``3,``4},Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``3,``1,``0},Smooth.Slinq.Context.ZipRemoveFlags)">
            <summary>
            Analog to Enumerable.Zip() that chains removal operations to the specified Slinq(s).
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Zip``6(Smooth.Slinq.Slinq{``3,``4},Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``3,``1,``5,``0},``5)">
            <summary>
            Analog to Enumerable.Zip() that chains removal operations to the left Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Zip``6(Smooth.Slinq.Slinq{``3,``4},Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{``3,``1,``5,``0},``5,Smooth.Slinq.Context.ZipRemoveFlags)">
            <summary>
            Analog to Enumerable.Zip() that chains removal operations to the specified Slinq(s).
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.ZipAll``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``0,``1})">
             <summary>
             Returns a Slinq that combines the corresponding elements from the supplied Slinqs into tuples and chains removal operations to the left Slinq.
             
             The returned Slinq will continue enumerating until it reaches the end of the longer of the supplied Slinqs.
             
             While a Slinq has elements remaining, the enumerated tuples will contain Some options containing the corresponding elements from the Slinq in the corresponding position.
            
             If either of the Slinqs is empty while the other still has elements remaining, the enumerated tuples will contain None options in place of the shorter Slinq's element until the enumeration is complete.
             
             Removal operations will not be chained to an empty Slinq.
             </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.ZipAll``4(Smooth.Slinq.Slinq{``2,``3},Smooth.Slinq.Slinq{``0,``1},Smooth.Slinq.Context.ZipRemoveFlags)">
             <summary>
             Returns a Slinq that combines the corresponding elements from the supplied Slinqs into tuples and chains removal operations to the specified Slinq(s).
             
             The returned Slinq will continue enumerating until it reaches the end of the longer of the supplied Slinqs.
             
             While a Slinq has elements remaining, the enumerated tuples will contain Some options containing the corresponding elements from the Slinq in the corresponding position.
            
             If either of the Slinqs is empty while the other still has elements remaining, the enumerated tuples will contain None options in place of the shorter Slinq's element until the enumeration is complete.
             
             Removal operations will not be chained to an empty Slinq.
             </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.ZipAll``5(Smooth.Slinq.Slinq{``3,``4},Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{Smooth.Algebraics.Option{``3},Smooth.Algebraics.Option{``1},``0})">
             <summary>
             Returns a Slinq that combines the corresponding elements from the supplied Slinqs using the supplied selector and chains removal operations to the left Slinq.
             
             The returned Slinq will continue enumerating until it reaches the end of the longer of the supplied Slinqs.
             
             While a Slinq has elements remaining, the selector will be passed Some options containing the corresponding elements from the Slinq.
            
             If either of the Slinqs is empty while the other still has elements remaining, None options will be passed to the selector in place of the shorter Slinq's element until the enumeration is complete.
             
             Removal operations will not be chained to an empty Slinq.
             </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.ZipAll``5(Smooth.Slinq.Slinq{``3,``4},Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{Smooth.Algebraics.Option{``3},Smooth.Algebraics.Option{``1},``0},Smooth.Slinq.Context.ZipRemoveFlags)">
             <summary>
             Returns a Slinq that combines the corresponding elements from the supplied Slinqs using the supplied selector and chains removal operations to the specified Slinq(s).
             
             The returned Slinq will continue enumerating until it reaches the end of the longer of the supplied Slinqs.
             
             While a Slinq has elements remaining, the selector will be passed Some options containing the corresponding elements from the Slinq.
            
             If either of the Slinqs is empty while the other still has elements remaining, None options will be passed to the selector in place of the shorter Slinq's element until the enumeration is complete.
             
             Removal operations will not be chained to an empty Slinq.
             </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.ZipAll``6(Smooth.Slinq.Slinq{``3,``4},Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{Smooth.Algebraics.Option{``3},Smooth.Algebraics.Option{``1},``5,``0},``5)">
             <summary>
             Returns a Slinq that combines the corresponding elements from the supplied Slinqs using the supplied selector and chains removal operations to the left Slinq.
             
             The returned Slinq will continue enumerating until it reaches the end of the longer of the supplied Slinqs.
             
             While a Slinq has elements remaining, the selector will be passed Some options containing the corresponding elements from the Slinq.
            
             If either of the Slinqs is empty while the other still has elements remaining, None options will be passed to the selector in place of the shorter Slinq's element until the enumeration is complete.
             
             Removal operations will not be chained to an empty Slinq.
             </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.ZipAll``6(Smooth.Slinq.Slinq{``3,``4},Smooth.Slinq.Slinq{``1,``2},Smooth.Delegates.DelegateFunc{Smooth.Algebraics.Option{``3},Smooth.Algebraics.Option{``1},``5,``0},``5,Smooth.Slinq.Context.ZipRemoveFlags)">
             <summary>
             Returns a Slinq that combines the corresponding elements from the supplied Slinqs using the supplied selector and chains removal operations to the specified Slinq(s).
             
             The returned Slinq will continue enumerating until it reaches the end of the longer of the supplied Slinqs.
             
             While a Slinq has elements remaining, the selector will be passed Some options containing the corresponding elements from the Slinq.
            
             If either of the Slinqs is empty while the other still has elements remaining, None options will be passed to the selector in place of the shorter Slinq's element until the enumeration is complete.
             
             Removal operations will not be chained to an empty Slinq.
             </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.ZipWithIndex``2(Smooth.Slinq.Slinq{``0,``1})">
            <summary>
            Zips the specified Slinq with a zero-based index.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Average``1(Smooth.Slinq.Slinq{System.Int32,``0})">
            <summary>
            Analog to Enumerable.Average().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Average``1(Smooth.Slinq.Slinq{System.Int64,``0})">
            <summary>
            Analog to Enumerable.Average().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Average``1(Smooth.Slinq.Slinq{System.Single,``0})">
            <summary>
            Analog to Enumerable.Average().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Average``1(Smooth.Slinq.Slinq{System.Double,``0})">
            <summary>
            Analog to Enumerable.Average().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.AverageOrNone``1(Smooth.Slinq.Slinq{System.Int32,``0})">
            <summary>
            Analog to Enumerable.Average(), but returns an option rather than throwing an exception on empty input.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.AverageOrNone``1(Smooth.Slinq.Slinq{System.Int64,``0})">
            <summary>
            Analog to Enumerable.Average(), but returns an option rather than throwing an exception on empty input.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.AverageOrNone``1(Smooth.Slinq.Slinq{System.Single,``0})">
            <summary>
            Analog to Enumerable.Average(), but returns an option rather than throwing an exception on empty input.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.AverageOrNone``1(Smooth.Slinq.Slinq{System.Double,``0})">
            <summary>
            Analog to Enumerable.Average(), but returns an option rather than throwing an exception on empty input.
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Sum``1(Smooth.Slinq.Slinq{System.Int32,``0})">
            <summary>
            Analog to Enumerable.Sum().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Sum``1(Smooth.Slinq.Slinq{System.Int64,``0})">
            <summary>
            Analog to Enumerable.Sum().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Sum``1(Smooth.Slinq.Slinq{System.Single,``0})">
            <summary>
            Analog to Enumerable.Sum().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinq.Sum``1(Smooth.Slinq.Slinq{System.Double,``0})">
            <summary>
            Analog to Enumerable.Sum().
            
            This operation will consume and dispose the Slinq.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Slinqable">
            <summary>
            Provides methods for creating basic Slinqs from various underlying collections or delegates.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Empty``1">
            <summary>
            Returns an empty Slinq of the specified type.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Smooth.Slinq.Slinqable.Slinq``1(System.Collections.Generic.IEnumerable{``0})" -->
        <member name="M:Smooth.Slinq.Slinqable.Slinq``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Returns a Slinq that enumerates over the elements of the specified list using the specified start index and step.
            
            If startIndex is outside the element range of the list, the resulting Slinq will be empty.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqWithIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Returns a Slinq that enumerates over the element, index pairs of the specified list using the specified start index and step.
            
            If startIndex is outside the element range of the list, the resulting Slinq will be empty.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Slinq``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns a Slinq that enumerates over the elements of the specified list in ascending order.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqWithIndex``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns a Slinq that enumerates over the element, index pairs of the specified list in ascending order.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Slinq``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Returns a Slinq that enumerates over the elements of the specified list in ascending order starting with the specified index.
            
            If startIndex is outside the element range of the list, the resulting Slinq will be empty.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqWithIndex``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Returns a Slinq that enumerates over the element, index pairs of the specified list in ascending order starting with the specified index.
            
            If startIndex is outside the element range of the list, the resulting Slinq will be empty.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns a Slinq that enumerates over the elements of the specified list in descending order.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqWithIndexDescending``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns a Slinq that enumerates over the element, index pairs of the specified list in descending order.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqDescending``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Returns a Slinq that enumerates over the elements of the specified list in decending order starting with the specified index.
            
            If startIndex is outside the element range of the list, the resulting Slinq will be empty.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqWithIndexDescending``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Returns a Slinq that enumerates over the element, index pairs of the specified list in decending order starting with the specified index.
            
            If startIndex is outside the element range of the list, the resulting Slinq will be empty.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Slinq``1(System.Collections.Generic.LinkedListNode{``0},System.Int32)">
            <summary>
            Returns a Slinq that starts with the value of the specified node and proceeds along node links.
            
            If step is positive, the Slinq will move along Next links, if step is negative the Slinq will move along Previous links.  If step is zero the Slinq will stay in place.
            
            If the specified node is null, the resulting Slinq will be empty.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqNodes``1(System.Collections.Generic.LinkedListNode{``0},System.Int32)">
            <summary>
            Returns a Slinq that starts with the specified node and proceeds along node links.
            
            If step is positive, the Slinq will move along Next links, if step is negative the Slinq will move along Previous links.  If step is zero the Slinq will stay in place.
            
            If the specified node is null, the resulting Slinq will be empty.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Slinq``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Returns a Slinq that enumerates over the values of the specified linked list in ascending order.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqDescending``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Returns a Slinq that enumerates over the values of the specified linked list in decending order.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqNodes``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Returns a Slinq that enumerates over the nodes of the specified linked list in ascending order.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.SlinqNodesDescending``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Returns a Slinq that enumerates over the nodes of the specified linked list in decending order.
            
            Slinqs created by this method will chain removal operations to the underlying list.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Slinq``1(Smooth.Algebraics.Option{``0})">
            <summary>
            Returns a Slinq that enumerates the specified option.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Range(System.Int32,System.Int32)">
            <summary>
            Returns a Slinq that enumerates the integers within a specified range.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Repeat``1(``0)">
            <summary>
            Returns a Slinq that repeats the specified value.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Repeat``1(``0,System.Int32)">
            <summary>
            Returns a Slinq that repeats the specified value the specified number of times.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence``1(``0,Smooth.Delegates.DelegateFunc{``0,``0})">
            <summary>
            Returns a Slinq that enumerates the sequence generated by specified seed value and selector function.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence``2(``0,Smooth.Delegates.DelegateFunc{``0,``1,``0},``1)">
            <summary>
            Returns a Slinq that enumerates the sequence generated by specified seed value and selector function.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence``1(``0,Smooth.Delegates.DelegateFunc{``0,Smooth.Algebraics.Option{``0}})">
            <summary>
            Returns a Slinq that enumerates the sequence generated by specified seed value and selector function.
            
            The enumeration will end when the selector returns a None option.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence``2(``0,Smooth.Delegates.DelegateFunc{``0,``1,Smooth.Algebraics.Option{``0}},``1)">
            <summary>
            Returns a Slinq that enumerates the sequence generated by specified seed value and selector function.
            
            The enumeration will end when the selector returns a None option.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.Byte,System.Byte)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.SByte,System.SByte)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.Int16,System.Int16)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.UInt16,System.UInt16)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.Int32,System.Int32)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.UInt32,System.UInt32)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.Int64,System.Int64)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.UInt64,System.UInt64)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.Single,System.Single)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.Double,System.Double)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="M:Smooth.Slinq.Slinqable.Sequence(System.Decimal,System.Decimal)">
            <summary>
            Returns a Slinq that enumerates the arithmetic sequence generated by the specified start and step values.
            
            Slinqs created by this method do not support element removal.
            </summary>
        </member>
        <member name="T:Smooth.Slinq.Test.SlinqTest">
            <summary>
            Test controller and (de)verifier for Smooth.Slinq.
            </summary>
        </member>
    </members>
</doc>
